#include "C:\Users\heming\source\repos\Pisces\core\co.hpp"



/* The codes below are generated by 'Element Studio'. */
#pragma comment(lib, "Ws2_32.lib")
#include <stdio.h>
#include <wchar.h>
#include <winsock2.h>
#include <Ws2tcpip.h>
wchar_t local_addr[] = L"127.0.0.1";
int port = 34242;

using namespace pisces;
fd_set r_fd,w_fd;
enum event
{
	r,
	w
};
struct soc
{
	SOCKET soc;
	event  e;
};

task<soc, emptyDerived,co_tag<initial_suspend_never_tag>> select_anscy(void)
{
	while (true)
	{
		fd_set r_cpy = r_fd, w_cpy = w_fd;
		auto ret = select(0,&r_cpy,&w_cpy,nullptr,nullptr);
		for (int i = 0; i < ret; ++i)
		{
			if(FD_ISSET(r_cpy.fd_array[i],&r_cpy))
				co_yield{ r_cpy.fd_array[i],event::r };
			if (FD_ISSET(w_cpy.fd_array[i], &w_cpy))
				co_yield{ w_cpy.fd_array[i],event::w };
		}
	}
}


int main(int ac, char* av[])
{
	WSADATA wsaData;
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
	{
		return -1;
	}
	SOCKET  sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock == INVALID_SOCKET)
	{
		return -1;
	}
	SOCKADDR_IN   addr;
	int net_buf;
	if (InetPtonW(AF_INET, local_addr, &net_buf) != 1)
	{
		return -1;
	}
	addr.sin_family = AF_INET;
	addr.sin_addr.S_un.S_addr = net_buf;
	addr.sin_port = htons(port);
	if (bind(sock, (LPSOCKADDR)&addr, sizeof(addr)) == SOCKET_ERROR)
	{
		return -1;
	}
	if (listen(sock, SOMAXCONN) == SOCKET_ERROR)
	{
		return -1;
	}
	SOCKET  sock_work = INVALID_SOCKET;
	SOCKADDR_IN   addr_conn;
	int length = sizeof(addr_conn);
	FD_SET(sock, &r_fd);
	auto t = select_anscy();
	while (true)
	{
		wchar_t buf[50] = L"Welcome to Server!";
		auto so = t.get();
		if (so.soc == sock)
		{
			sock_work = accept(sock, (LPSOCKADDR)&addr_conn, &length);
			if (sock_work == INVALID_SOCKET)
			{
				continue;
			}
			FD_SET(sock_work, &r_fd);
			FD_SET(sock_work, &w_fd);
			t.resume();
		}
		if (t.get().soc == sock_work && t.get().e == event::w)
		{
			wchar_t addr_str[46] = L"";
			InetNtopW(AF_INET, (void*)&addr_conn, addr_str, 46);
			wprintf(L"client address: %s\n", addr_str);
			//send data of string to client(do not send L'\0')
			send(sock_work, (const char*)buf, wcslen(buf) * sizeof(wchar_t), 0);
			FD_CLR(sock_work, &w_fd);
			t.resume();
		}
		if (t.get().soc == sock_work && t.get().e == event::r)
		{
			wchar_t buf[50] = L"";
			int received = 0;
			// receive data of string from server (does not include L'\0')
			received = recv(sock_work, (char*)buf, sizeof(buf), 0);
			if (received > 0)
			{
				buf[received / 2] = L'\0';
				wprintf(L"received: %s\n", buf);
			}
			t.resume();
		}
		closesocket(sock_work);
	}
	closesocket(sock);
	WSACleanup();
	return 0;
}
